package  {	import flash.display.MovieClip;import flash.events.Event;import flash.events.KeyboardEvent;public class Main extends MovieClip {		const SPADES:Number = 1;      // List	const CLUBS:Number = 2;       // Detelina	const HEARTS:Number = 3;      // Srce	const DIAMONDS:Number = 4;    // Karo	const JUMPER:Number = 5;      // Skocko    const STAR:Number = 6;        // Zvezda    const ONE:Number = 7;          // One    const TWO:Number = 8;         // Two    const THREE:Number = 9;       // Three    const FOUR:Number = 10;       // Four    const ZERO:Number = 11;       // Zero		const CHECKED:String = "x";	const RULEDOUT:String = "y";		var potentialCombinations:Array;	var keyPressedQueue:Number; //which sign to expect (1-6)	var currentTryOrdinal:Number; //the ordinal of the try that is currently hapenning (1-7)	var currentTry:Array; //the current Try as an array		public function Main() {			    initNewGame();	    	}		function initNewGame()	{		initButtons();	    initAllCombinations();	    initAllCombinationsResults();		possibleCombinations.resetAllCombinations();		resetAllTryCombinations();		//stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDowned);				keyPressedQueue = 0;		currentTryOrdinal = 1;		currentTry = new Array();		}	function initButtons() {		var buttonSpades:EntryButton = (EntryButton)(getChildByName("pikButton")); buttonSpades.setSign(SPADES);		var buttonClubs:EntryButton = (EntryButton)(getChildByName("trefButton")); buttonClubs.setSign(CLUBS);		var buttonHearts:EntryButton = (EntryButton)(getChildByName("hercButton")); buttonHearts.setSign(HEARTS);		var buttonDiamonds:EntryButton = (EntryButton)(getChildByName("karoButton")); buttonDiamonds.setSign(DIAMONDS);		var buttonJumper:EntryButton = (EntryButton)(getChildByName("skockoButton")); buttonJumper.setSign(JUMPER);		var buttonStar:EntryButton = (EntryButton)(getChildByName("zvezdaButton")); buttonStar.setSign(STAR);		var buttonOne:EntryButton = (EntryButton)(getChildByName("oneButton")); buttonOne.setSign(ONE);		var buttonTwo:EntryButton = (EntryButton)(getChildByName("twoButton")); buttonTwo.setSign(TWO);		var buttonThree:EntryButton = (EntryButton)(getChildByName("threeButton")); buttonThree.setSign(THREE);		var buttonFour:EntryButton = (EntryButton)(getChildByName("fourButton")); buttonFour.setSign(FOUR);		var buttonZero:EntryButton = (EntryButton)(getChildByName("zeroButton")); buttonZero.setSign(ZERO);	}		function initAllCombinations()	{	    trace("In initAllCombinations");	    potentialCombinations = new Array();		var i,j,k,l:Number;	 		for(i = 1; i < 7; i++)		{		    for(j = 1; j < 7; j++)		    {		        for(k = 1; k < 7; k++)		        {		            for(l = 1; l < 7; l++)		            {		                potentialCombinations.push(new Array(i,j,k,l));	         	        		            } 	         	  		        }     	         	  		    }     		}        trace("There is " + potentialCombinations.length + " combinations");			}	function initAllCombinationsResults() {        result1.x = 243; result1.y = 147;        result2.x = 243; result2.y = 191;        result3.x = 243; result3.y = 237;        result4.x = 243; result4.y = 285;        result5.x = 243; result5.y = 332;        result6.x = 243; result6.y = 378;        result7.x = 243; result7.y = 424;        result8.x = 243; result8.y = 471;	}		function resetAllTryCombinations()	{	    combination1.reset();		combination2.reset();		combination3.reset();		combination4.reset();		combination5.reset();		combination6.reset();		combination7.reset();		combination8.reset();                        			}		//When new combination and result appear, this is a new restriction, so it needs to be accounted for also	function accountForAdditionalRestriction(restriction:Try)	{		var newPotentialCombinations:Array = new Array();				restriction.convertSignsToNumbers();				var r:Try = Try.cloneTry(restriction);				var trySigns:Array = r.getSigns();		var tryResult:Array = r.getRezult();				for each(var poc:Array in potentialCombinations) {		    			r = Try.cloneTry(restriction);				    trySigns = r.getSigns();		    tryResult = r.getRezult();			trace("Next check:");						//pc will possibly get its signs set to CHECKED, so we have to preserve the original as poc			var pc:Array = poc.concat();					    		    var passes:Boolean = true;		    var correctCounter:Number = 0;		    var misplacedCounter:Number = 0;					 			//correct pieces check 			//trace("Comparing the misplaced signs:")		    for(var i:Number = 0; i < 4; i++) {			    //trace("Comparing " + pc[i] + " and " + trySigns[i]);			    if (pc[i] == trySigns[i]) {									correctCounter++;										pc[i] = CHECKED;					trySigns[i] = RULEDOUT;																	}			    				}			            //misplaced pieces check	            //trace("Comparing the misplaced signs:")						for(i = 0; i < 4; i++) {			    for(var j:Number = 0; j < 4; j++) {				    //trace("Comparing " + pc[i] + " and " + trySigns[j]);				  					if(pc[i] == trySigns[j]) {											misplacedCounter++;						pc[i] = CHECKED;						trySigns[j] = RULEDOUT;																							}			    				}			}						if (tryResult[0] == correctCounter) {			    if (tryResult[1] == misplacedCounter) {			        newPotentialCombinations.push(poc);			    }			}									trace("Checking " + poc[0] + poc[1] + poc[2] + poc[3] + " against restriction: " + restriction.returnAsString() + " gives: " + correctCounter + " " + misplacedCounter);		} 		        potentialCombinations = newPotentialCombinations;  									}		function traceAllPossibleCombinations()	{	    trace("writing all possible combinations, there is " + potentialCombinations.length);	    if (potentialCombinations.length < 100)		{	        for each (var pc:Array in potentialCombinations)			{			    trace("Combination: " + pc[0] + " , " + pc[1] + " , " + pc[2] + " , " + pc[3]);						}		}		}		function displayPotentialCombinations()	{	    if (potentialCombinations.length > 32) {		    for (var i:Number = 0; i < 32; i++) {                var poc:Array = potentialCombinations[i];				trace ("i, poc[0], poc[1], poc[2], poc[3] je: " + i + ", " + poc[0] + ", " + poc[1] + ", " + poc[2] + ", " + poc[3]); 				possibleCombinations.setCombination(i, poc[0], poc[1], poc[2], poc[3]);                						}			               					}		else {		    for(i = 0; i < potentialCombinations.length; i++) {			    poc = potentialCombinations[i];				possibleCombinations.setCombination(i, poc[0], poc[1], poc[2], poc[3]);		                }					}	    	}			function buttonClicked(whichPar:Number) {        trace("whichPar: " + whichPar);		    var which:String;	    switch(whichPar) {	    	case 1: which = "p"; break;	    	case 2: which = "t"; break;	    	case 3: which = "h"; break;	    	case 4: which = "k"; break;	    	case 5: which = "s"; break;	    	case 6: which = "z"; break;	    	case 7: which = "1"; break;	    	case 8: which = "2"; break;	    	case 9: which = "3"; break;	    	case 10: which = "4"; break;	    	case 11: which = "0"; break;	    }		    keyPressedQueue++;		//trace("keyPressedQueue je: " + keyPressedQueue);		//trace("currentTryOrdinal je: " + currentTryOrdinal);							var c:Combination;		var r:CombinationResult;				//Find which try combination to update		switch(currentTryOrdinal) {		    case 1:	c = combination1; 			        r = result1; break;			case 2:	c = combination2; 			        r = result2; break;			case 3:	c = combination3; 			        r = result3; break;			case 4:	c = combination4; 			        r = result4; break;			case 5:	c = combination5; 			        r = result5; break;			case 6:	c = combination6; 			        r = result6; break;			case 7:	c = combination7; 			        r = result7; break;		}				//Find which sign in the current try combination to update		switch(keyPressedQueue) {			case 1: currentTry[1] = which; 			        updateTryCombination(c, 1, currentTry[1]); break;			        			case 2: currentTry[2] = which; 			        updateTryCombination(c, 2, currentTry[2]); break;			case 3: currentTry[3] = which;                    updateTryCombination(c, 3, currentTry[3]); break;			case 4: currentTry[4] = which; 			        updateTryCombination(c, 4, currentTry[4]); break;			case 5: currentTry[5] = which; break;			        			case 6: currentTry[6] = which;						        updateTryResult(r, currentTry[5], currentTry[6]);			        currentTryOrdinal++; 			        keyPressedQueue = 0; 					 					var t:Try = new Try();					t.setSigns(currentTry[1],							   currentTry[2],							   currentTry[3],							   currentTry[4]);					t.setRezult(currentTry[5],								currentTry[6]);																													accountForAdditionalRestriction(t); 										traceAllPossibleCombinations(); 					possibleCombinations.resetAllCombinations();										displayPotentialCombinations(); break;		}		}		function updateTryCombination(whichTryCombination:Combination, whichSign, toWhichSign:String)	{	    var signNumber:Number;	    switch(toWhichSign) {		    case "p": signNumber = 1; break;			case "t": signNumber = 2; break;			case "h": signNumber = 3; break;			case "k": signNumber = 4; break;			case "s": signNumber = 5; break;			case "z": signNumber = 6; break;		}			    whichTryCombination.setSignTo(whichSign, signNumber);		}		function updateTryResult(r:CombinationResult, r1, r2:Number)	{	    trace ("r1 and r2 are: " + r1 + " " + r2);	    r.displayOutcome(r1, r2);	}		}}